# -*- coding: utf-8 -*-
"""PitsModel.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1T5NpoFF4HATYM1mZI9ucmub-wm8l1XQR
"""

from pomegranate.distributions import Categorical
from pomegranate.distributions import ConditionalCategorical
from pomegranate.bayesian_network import BayesianNetwork
import torch
import itertools as it

# Given x and y, get valid adjacent cells in a 4 by 4 grid
def get_pits_adjacent_cells(x, y):
        adjacent_cells = [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]

        valid_adjacent_cells = []
        for cell in adjacent_cells:
          if not (cell[0] == 0 or cell[0] == 5 or cell[1] == 0 or cell[1] == 5):
            valid_adjacent_cells.append(cell)
        return valid_adjacent_cells

# Pomegrate 1 uses tensors (i.e. lists of lists of lists of lists of...) so it can interoperate with PyTorch

# If we want to avoid having to carefully count how indented we are with lists in lists [[[[[[[[]]]]]]]]
# and making sure the sum is 1 we could get fancy and create a class for predicates, something like:

class Predicate():
    def __init__(self, prob: float):
        self.p = prob

    def toList(self):
        return [1-self.p, self.p]

    def toCategorical(self):
        return Categorical([self.toList()])

def reshape_list(flat_list, shape):
    """
    Reshapes a flat list into a multi-dimensional list based on the given shape.

    Args:
        flat_list (list): The flat list to reshape.
        shape (list of int): The desired shape of the multi-dimensional list.

    Returns:
        list: The reshaped multi-dimensional list.
    """
    if not shape:
        return flat_list[0] if flat_list else []
    size = shape[0]
    sub_shape = shape[1:]
    chunk_size = len(flat_list) // size
    return [reshape_list(flat_list[i * chunk_size : (i + 1) * chunk_size], sub_shape) for i in range(size)]

def get_conditional_probabilities(list_of_pits):
  # build the truth table
  combinations = it.product([False, True], repeat=len(list_of_pits))

  cases = []
  for combo in combinations:
    # If any pit is True, then breeze is going to be True
    if True in combo:
      p = 1.0
    else:
      p = 0.0
    cases.append(Predicate(p).toList())

  shape = [2] * len(list_of_pits)
  reshaped_cases = reshape_list(cases, shape)

  return reshaped_cases

def pits_bayesian_model():
  # Construct breeze conditionals probablities
  breeze_nodes = {}

  for x in range(1, 5):
    for y in range(1, 5):
      adjacent_cells = get_pits_adjacent_cells(x, y)

      cell_list = []
      for cell in adjacent_cells:
        # skip if 1, 1, since there are no pits
        if cell[0] == 1 and cell[1] == 1:
          continue

        cell_list.append("pit_" + str(cell[0]) + "_" + str(cell[1]))


      breeze_cases = get_conditional_probabilities(cell_list)
      breeze = ConditionalCategorical([
        breeze_cases
      ])

      breeze_nodes["breeze_" + str(x) + "_" +  str(y)] = breeze


  # Pits probablities
  # We are assume 0.2 rate of pits
  pits = {}
  for i in range(1, 5):
    for j in range(1, 5):
        pits[f'pit_{i}_{j}'] = Predicate(0.2).toCategorical()

  # Load variables: add all the pits and breeze nodes
  prediction_variables_index = []
  variables = []
  for pit in pits:
    if pit == "pit_1_1":
      continue
    prediction_variables_index.append(pit)
    variables.append(pits[pit])

  for breeze_node in breeze_nodes:
    prediction_variables_index.append(breeze_node)
    variables.append(breeze_nodes[breeze_node])

  #build the edges
  # Loop through each possible pit location, then all possible breeze nodes
  edges = []

  for x in range(1, 5):
    for y in range(1, 5):
      breeze_node_str = "breeze_" + str(x) + "_" + str(y)
      adjacent_cells = get_pits_adjacent_cells(x, y)

      for cell in adjacent_cells:
        # we won't have pit in 1_1
        if cell == (1, 1):
          continue

        edges.append((pits["pit_" + str(cell[0]) + "_" + str(cell[1])], breeze_nodes[breeze_node_str]))


  pits_model_new = BayesianNetwork(variables, edges)
  return pits_model_new, prediction_variables_index

# Util function that maps variables to predictions
def get_pit_probability_dict(prediction_variables_index, predictions):
  prediction_dict = {}
  for index, value in enumerate(predictions):
    key = prediction_variables_index[index]
    prediction_dict[key] = value

  return prediction_dict

# Based on observations, get updated probabilities
def update_probabilities(pits_model, tesnor_list, prediction_variables_index, location, observation):

  # get the variable index
  location_index = prediction_variables_index.index(location)

  # set the observation
  tesnor_list[location_index] = observation

  X = torch.tensor([tesnor_list])
  X_masked = torch.masked.MaskedTensor(X, mask=X >= 0)
  predictions = pits_model.predict_proba(X_masked)
  return predictions, tesnor_list

def test_pits_model():
  pits_model, prediction_variables_index = pits_bayesian_model()

  tesnor_list = [-1, -1, -1, -1, -1,
               -1, -1, -1, -1, -1,
               -1, -1, -1, -1, -1,
               -1, -1, -1, -1, -1,
               -1, -1, -1, -1, -1,
               -1, -1, -1, -1, -1,
               -1]

  current_location_x = 2
  current_location_y = 2
  current_breeze_location = "breeze_" + str(current_location_x) + "_" + str(current_location_y)

  observation = 1

  predictions, tesnor_list = update_probabilities(pits_model, tesnor_list, prediction_variables_index, current_breeze_location, observation)
  print(prediction_variables_index)
  print(predictions)
  print(tesnor_list)

#test_pits_model()
